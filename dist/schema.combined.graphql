# COMBINED SCHEMA
# Auto-generated from schema files


# ----- meta-data.graphql ----- 
type _Node_Update_ {
  id: ID!
  comment: String
  updated_on: DateTime @search
}
# ----- END meta-data.graphql ----- 

# ----- auth/auth.graphql ----- 
# USER AUTHENTICATION
# values in camelcase are due to @auth/core adapter type definition

type Account {
  id: ID

  type: String
  provider: String @search(by: [hash])
  providerAccountId: String @search(by: [hash])
  refreshToken: String
  expires_at: Int64
  accessToken: String
  token_type: String
  refresh_token: String
  access_token: String
  scope: String
  id_token: String
  session_state: String
  user: User @hasInverse(field: "accounts")
}

type Session {
  id: ID

  expires: DateTime
  sessionToken: String @search(by: [hash])
  user: User @hasInverse(field: "sessions")
}

type User {
  id: ID

  name: String
  email: String @id
  emailVerified: DateTime
  image: String
  accounts: [Account] @hasInverse(field: "user")
  sessions: [Session] @hasInverse(field: "user")
  citizen_profile: _Citizen_Profile_ @hasInverse(field: "user")
}

type VerificationToken {
  id: ID

  identifier: String @search(by: [hash])
  token: String @search(by: [hash])
  expires: DateTime
}


# ----- END auth/auth.graphql ----- 

# ----- auth/citizen.graphql ----- 
type _Citizen_Profile_ {
  id: ID

  user: User @hasInverse(field: "citizen_profile")

  # for now country defaults to India
  # country: [_Country_]

  # what should the user follow? region version or entity?
  # I think root entity it holds the identity of the region for the given time and connects to everything else.
  state_or_union_territories: [_Indian_State_Union_Territory_] @hasInverse(field: "citizen_followers")
  districts: [_Indian_District_] @hasInverse(field: "citizen_followers")
  loksabha_constituencies: [_Indian_Loksabha_Constituency_] @hasInverse(field: "citizen_followers")
  vidhansabha_constituencies: [_Indian_Vidhansabha_Constituency_] @hasInverse(field: "citizen_followers")

  # policy subjects
  policy_domains: [_Public_Policy_Domain_] @hasInverse(field: "citizen_followers")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}
# ----- END auth/citizen.graphql ----- 

# ----- language.graphql ----- 
# language and scripts
# text, especially names can be in multiple languages and scripts
type _Language_ {
  id: ID!

  name_en: String! @id
  names: [_Name_] @hasInverse(field: "language")
  scripts: [_Script_] @hasInverse(field: "languages")

  wikidata_qid: String @search(by: [hash])
  wikipedia_page: String @search(by: [fulltext])

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

type _Script_ {
  id: ID!

  name_en: String! @id
  names: [_Name_] @hasInverse(field: "script")
  languages: [_Language_] @hasInverse(field: "scripts")

  wikidata_qid: String @search(by: [hash])
  wikipedia_page: String @search(by: [fulltext])

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

# instance of language + script combination.
type _Language_Script_ {
  id: ID!

  name_en: String! @id
  language: _Language_!
  script: _Script_!

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}
# ----- END language.graphql ----- 

# ----- name.graphql ----- 
# the "WHO" of 5W1H #ENTRY_NODE
# #ENTRY_NODE
# name of all entities in the knowledge graph.
# an entry point for all.
# one name can be shared by multiple entities.
type _Name_ {
  id: ID!

  name: String! @id @search(by: [hash, term, fulltext])

  # a set of characters can be same for different combinations of languages and scripts
  language_script: [_Language_Script_]
  case_sensitive: Boolean

  # NAMES OF Languages and Scripts
  language: [_Language_] @hasInverse(field: "names")
  script: [_Script_] @hasInverse(field: "names")

  person: [_Person_] @hasInverse(field: "names")

  # NAMES OF public policy domains like defence, healthcare etc.
  public_policy_domain: [_Public_Policy_Domain_] @hasInverse(field: "names")
  public_policy_domain_group: [_Public_Policy_Domain_Group_] @hasInverse(field: "names")

  # NAMES OF Countries
  country: [_Country_] @hasInverse(field: "names")
  # in_zonal_council: [_IN_Zonal_Council_]

  map_data_source_name: [_Source_] @hasInverse(field: "names")

  country_event: [_Country_Event_] @hasInverse(field: "names")
  country_government: [_Country_Government_] @hasInverse(field: "names")

  government_system_type_economic_system: [_Government_System_Types_Economic_System_] @hasInverse(field: "names")
  government_system_type_religion: [_Government_System_Types_Religion_] @hasInverse(field: "names")
  government_system_type_head_of_state_or_government: [_Government_System_Types_Head_Of_State_Or_Government]
    @hasInverse(field: "names")
  government_system_type_partisan_systems: [_Government_System_Types_Partisan_Systems_] @hasInverse(field: "names")
  government_system_type_democracy: [_Government_System_Types_Democracy_] @hasInverse(field: "names")
  government_system_type_oligarchy: [_Government_System_Types_Oligarchy_] @hasInverse(field: "names")
  government_system_type_autocratic: [_Government_System_Types_Autocratic_] @hasInverse(field: "names")
  government_system_type_monarchy: [_Government_System_Types_Monarchy_] @hasInverse(field: "names")
  government_system_type_authority_distribution: [_Government_System_Types_Authority_Distribution_]
    @hasInverse(field: "names")
  government_system_type_authority_concentration: [_Government_System_Types_Authority_Concentration_]
    @hasInverse(field: "names")
  government_system_type_authority_source: [_Government_System_Types_Authority_Source_] @hasInverse(field: "names")
  government_system_type_authority_status: [_Government_System_Types_Authority_Status_] @hasInverse(field: "names")

  indian_union_government_department: [_Indian_Union_Government_Department_] @hasInverse(field: "names")
  indian_union_government_ministry: [_Indian_Union_Government_Ministry_] @hasInverse(field: "names")
  indian_government_official_role: [_Indian_Government_Official_Role_] @hasInverse(field: "names")

  indian_union_parliament_loksabha: [_Indian_Loksabha_] @hasInverse(field: "names")

  indian_loksabha_constituency: [_Indian_Loksabha_Constituency_] @hasInverse(field: "names")
  indian_loksabha_constituency_reorganisation: [_Indian_Loksabha_Constituency_Reorganisation_]
    @hasInverse(field: "names")
  indian_loksabha_election: [_Indian_Loksabha_Election_] @hasInverse(field: "names")

  indian_vidhansabha_constituency: [_Indian_Vidhansabha_Constituency_] @hasInverse(field: "names")
  indian_vidhansabha_constituency_reorganisation: [_Indian_Vidhansabha_Constituency_Reorganisation_]
    @hasInverse(field: "names")

  indian_state_union_territory: [_Indian_State_Union_Territory_] @hasInverse(field: "names")
  indian_state_union_territory_reorganisation: [_Indian_State_Union_Territory_Reorganisation_]
    @hasInverse(field: "names")

  indian_district: [_Indian_District_] @hasInverse(field: "names")
  indian_district_reorganisation: [_Indian_District_Reorganisation_] @hasInverse(field: "names")

  indian_sub_district: [_Indian_Sub_District_] @hasInverse(field: "names")
  indian_sub_district_reorganisation: [_Indian_Sub_District_Reorganisation_] @hasInverse(field: "names")

  indian_political_party: [_Indian_Political_Party_] @hasInverse(field: "names")

  indian_legal_document: [_Indian_Legal_Document_] @hasInverse(field: "names")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}
# ----- END name.graphql ----- 

# ----- person.graphql ----- 
type _Person_ {
  id: ID!

  names: [_Name_] @hasInverse(field: "person")

  born: _Date_Time_
  died: _Date_Time_

  # Should not be separate wikipedia node.
  # 1:1 relationship. Will be another high fanout node.
  wikidata_qid: String @search(by: [hash])
  wikipedia_page: String @search(by: [fulltext])

  indian_politician: _Indian_Politician_ @hasInverse(field: "person")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

# SINGLE_NODE_TYPE
type _Indian_Politician_ {
  id: ID!

  # names: [_Name_!]! @hasInverse(field: "indian_politician")

  political_party_memberships: [_Indian_Political_Party_Member_] @hasInverse(field: "politician")

  person: _Person_ @hasInverse(field: "indian_politician")

  # elections in which participated
  loksabha_elections_contested: [_Indian_Loksabha_Constituency_Election_Candidate_] @hasInverse(field: "candidate")

  # official positions held
  loksabha_member: [_Indian_Loksabha_Member_] @hasInverse(field: "position_held_by")
  # rajyasabha_member: [_Indian_Rajyasabha_Member_]
  # vidhansabha_member: [_Indian_Vidhansabha_Member_]
  prime_minister: [_Indian_Prime_Minister_] @hasInverse(field: "position_held_by")
  cabinet_minister: [_Indian_Union_Government_Cabinet_Minister_] @hasInverse(field: "position_held_by")
  minister_of_state_independent_charge: [_Indian_Union_Government_Minister_Of_State_Independent_Charge_]
    @hasInverse(field: "position_held_by")
  minister_of_state: [_Indian_Union_Government_Minister_Of_State_] @hasInverse(field: "position_held_by")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}
# ----- END person.graphql ----- 

# ----- sources.graphql ----- 
# describe source
type _Source_ {
  id: ID!

  name_id: String! @id @search(by: [exact, term, fulltext])

  # about source
  names: [_Name_] @hasInverse(field: "map_data_source_name")
  source_description: String

  # link to source
  source_urls: [String]

  source_data: [_Source_Data_] @hasInverse(field: "source")
}

type _Source_Data_ {
  id: ID!

  source: _Source_ @hasInverse(field: "source_data")

  # urls specific to the data
  source_url: [String]
  # original stringified data for this instance
  source_data: String

  geo: [_Geo_] @hasInverse(field: "source")
}

# ----- END sources.graphql ----- 

# ----- geo.graphql ----- 
enum _Location_Or_Region_Category_ {
  Location
  Region
}

enum _Geo_Precision_ {
  # e.g. countries in world map on low res map image
  Extra_Low
  Low
  Medium
  High
  Very_High
  Near_Real_World
}

# the "WHERE" of 5W1H
# #ENTRY_NODE
# tile by tile geo information and how its related to political regions
type _Geo_ {
  id: ID!
  # CHANGE: not to include category, if has location,
  category: _Location_Or_Region_Category_ @search(by: [exact])

  source: _Source_Data_ @hasInverse(field: "geo")

  # if the category is location
  location: Point @search

  # if the category is region
  area: MultiPolygon @search

  # how close to real the map data is. kind of like confidence score
  precision: Int @search

  country_boundary_actual: _Country_Region_ @hasInverse(field: "geo_boundary_self_actual")
  country_boundary_self_official: _Country_Region_ @hasInverse(field: "geo_boundary_self_official")
  country_boundary_world_official: _Country_Region_ @hasInverse(field: "geo_boundary_world_official")

  india_zonal_council_divisions: _Country_Region_ @hasInverse(field: "geo_country_divisions_zonal_council")
  india_state_union_territory_divisions: _Country_Region_
    @hasInverse(field: "geo_country_divisions_state_union_territory")
  india_district_divisions: _Country_Region_ @hasInverse(field: "geo_country_divisions_district")
  india_vidhansabha_constituency_divisions: _Country_Region_
    @hasInverse(field: "geo_country_divisions_loksabha_constituency")
  india_loksabha_constituency_divisions: _Country_Region_
    @hasInverse(field: "geo_country_divisions_vidhansabha_constituency")

  indian_states_union_territory_boundary: _Indian_State_Union_Territory_Version_Region_
    @hasInverse(field: "geo_boundary")
  indian_district_boundary: _Indian_District_Version_Region_ @hasInverse(field: "geo_boundary")
  indian_sub_district_boundary: _Indian_Sub_District_Version_Region_ @hasInverse(field: "geo_boundary")

  indian_loksabha_constituency_boundary: _Indian_Loksabha_Constituency_Version_Region_
    @hasInverse(field: "geo_boundary")
  indian_vidhansabha_constituency_boundary: _Indian_Vidhansabha_Constituency_Version_Region_
    @hasInverse(field: "geo_boundary")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}
# ----- END geo.graphql ----- 

# ----- date-time.graphql ----- 
enum Date_Time_Precision_Category {
  Year
  Month
  Day
  Hour
  Minute
  Second
}

type _Date_Time_ {
  id: ID!

  date_time_id: String! @id @search(by: [exact, term, fulltext])

  year: Int @search
  month: Int @search
  day: Int @search
  hour: Int @search
  minute: Int @search
  second: Int @search

  timezone_independent: Boolean @search
  timezone: String @search

  date_time_precision: Date_Time_Precision_Category @search(by: [exact])

  from_datetime_country_event: [_Country_Event_] @hasInverse(field: "datetime_from")
  to_datetime_country_event: [_Country_Event_] @hasInverse(field: "datetime_to")

  indian_state_union_territory_established_on: [_Indian_State_Union_Territory_] @hasInverse(field: "established_on")
  indian_state_union_territory_disestablished_on: [_Indian_State_Union_Territory_]
    @hasInverse(field: "disestablished_on")

  indian_district_reorganisation: [_Indian_District_Reorganisation_] @hasInverse(field: "reorganised_on")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

# ----- END date-time.graphql ----- 

# ----- country.graphql ----- 
# the "WHAT" of 5W1H.
# will have to have multiple node types for the events.
#
type _Country_Event_ {
  id: ID!

  # if involves multiple countrys
  country: [_Country_] @hasInverse(field: "events")

  # specific to this event. should be able to identify the event and country.
  # would be best if the value can be unique, though not setting that as a condition as of now.
  names: [_Name_] @hasInverse(field: "country_event")
  description: String! @search(by: [exact, fulltext, term])

  # broad categories. "term criteria": can be applicable to any country.
  # "Declared Independence", "Civil War", "Independence Day", "Declared as Republic", "Declared War", "Hoasted Olympic", "Launched a Sattelite"
  # cannot be an enum (at least at this point) since can have too many values,
  # unless we reach a point where we have a sure number which may not change much.
  event_type: String! @search(by: [exact, fulltext, term])

  # time range event or one time
  one_time_event: Boolean

  datetime_from: _Date_Time_! @hasInverse(field: "from_datetime_country_event")
  datetime_to: _Date_Time_ @hasInverse(field: "to_datetime_country_event")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

type _Country_ {
  id: ID!
  name_id: String! @id @search(by: [exact, term, fulltext])

  names: [_Name_!]! @hasInverse(field: "country")

  regions: [_Country_Region_] @hasInverse(field: "country")

  government: _Country_Government_ @hasInverse(field: "governs_country")

  events: [_Country_Event_] @hasInverse(field: "country")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

# political regions associated with and within a country
type _Country_Region_ {
  id: ID!

  name_id: String! @id @search(by: [exact, term, fulltext])

  country: _Country_ @hasInverse(field: "regions")

  # date on which the region changed
  # e.g. sikkim added to India
  # version: DateTime @search

  established: _Country_Event_
  disestablished: _Country_Event_

  # how the country region related to other region types
  # capital: [_Countryal_Capital_City_]
  # zonal_council: [_IN_Zonal_Council_Region_] @hasInverse(field: "country")
  # state: [_IN_State_Region_] @hasInverse(field: "country")
  # union_territory: [_IN_Union_Territory_Region_] @hasInverse(field: "country")

  # array because, there can be multiple version with varying precision.
  # low precision for maps, high precicion for search and computation
  geo_boundary_self_actual: [_Geo_] @hasInverse(field: "country_boundary_actual")

  # boundaries recognized by the national authorities
  # e.g. PoK is part of India as per Indian government, although its not under GOI administration
  geo_boundary_self_official: [_Geo_] @hasInverse(field: "country_boundary_self_official")
  # a country may accept or reject borders of certain countries based on its foriegn policy
  # this is the world map as per the country
  geo_boundary_world_official: [_Geo_] @hasInverse(field: "country_boundary_world_official")

  geo_country_divisions_zonal_council: [_Geo_] @hasInverse(field: "india_zonal_council_divisions")
  geo_country_divisions_state_union_territory: [_Geo_] @hasInverse(field: "india_state_union_territory_divisions")
  geo_country_divisions_district: [_Geo_] @hasInverse(field: "india_district_divisions")
  geo_country_divisions_loksabha_constituency: [_Geo_] @hasInverse(field: "india_vidhansabha_constituency_divisions")
  geo_country_divisions_vidhansabha_constituency: [_Geo_] @hasInverse(field: "india_loksabha_constituency_divisions")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

type _Country_Government_ {
  id: ID!
  name_id: String! @id @search(by: [exact, term, fulltext])

  # Government of India, भारत सरकार
  names: [_Name_!]! @hasInverse(field: "country_government")

  governs_country: _Country_ @hasInverse(field: "government")

  # official declaration of government system
  active_government_system_type_official: _Government_System_Type_ @hasInverse(field: "active_official_system_type_of")

  # world country governments
  # to add country specific data to each one
  # one country can have had variety of government systems in the past
  # individual type can help adapt to the country specific needs
  # e.g. India had in the past, a dominion government, provisional government, british-colony government, east indian company government
  india_government_system_active: _Indian_Government_System_ @hasInverse(field: "country")
  # india_government_system_active: [_Indian_Government_System_] @hasInverse(field: "country")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}
# ----- END country.graphql ----- 

# ----- public-policy-domains.graphql ----- 
type _Public_Policy_Domain_Group_ {
  id: ID!

  name_id: String! @id @search(by: [hash, term])

  names: [_Name_] @hasInverse(field: "public_policy_domain_group")
  description: String

  domains_in_group: [_Public_Policy_Domain_] @hasInverse(field: "public_policy_domain_group")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

type _Public_Policy_Domain_ {
  id: ID!

  name_id: String! @id @search(by: [hash, term, fulltext])

  names: [_Name_] @hasInverse(field: "public_policy_domain")
  description: String

  public_policy_domain_group: _Public_Policy_Domain_Group_ @hasInverse(field: "domains_in_group")

  super_domain: [_Public_Policy_Domain_] @hasInverse(field: "sub_domain")
  sub_domain: [_Public_Policy_Domain_] @hasInverse(field: "super_domain")

  government_ministries_departments: _Public_Policy_Domain_Government_Ministries_Departments_
    @hasInverse(field: "public_policy_domain")

  citizen_followers: [_Citizen_Profile_] @hasInverse(field: "policy_domains")

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}

# LISTING_NODE. connects all national and state ministries/departments in domains.
type _Public_Policy_Domain_Government_Ministries_Departments_ {
  id: ID!

  public_policy_domain: [_Public_Policy_Domain_] @hasInverse(field: "government_ministries_departments")

  indian_union_government_ministries: [_Indian_Union_Government_Ministry_]
    @hasInverse(field: "policy_domain_ministries_list")
  indian_union_government_departments: [_Indian_Union_Government_Department_]
    @hasInverse(field: "policy_domain_departments_list")
  # indian_state_government: [_Indian_Union_Government_Ministry_]
  # indian_union_territory_government: [_Indian_Union_Government_Ministry_]

  node_created_on: DateTime
  node_updates: [_Node_Update_]
}
# ----- END public-policy-domains.graphql ----- 
